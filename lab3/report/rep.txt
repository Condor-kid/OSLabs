实验题目:
用C和汇编实现操作系统内核

实验目的:
将实验二的原型操作系统分离为引导程序和MYOS内核，由引导程序加载内核，用C和汇编实现操作系统内核.

实验要求:
1.扩展内核汇编代码，增加一些有用的输入输出函数，供C模块中调用
2.提供用户程序返回内核的一种解决方案
3.在内核的C模块中实现增加批处理能力
在磁盘上建立一个表，记录用户程序的存储安排
可以在控制台命令查到用户程序的信息，如程序名、字节数、在磁盘映像文件中的位置等
设计一种命令，命令中可加载多个用户程序，依次执行，并能在控制台发出命令
在引导系统前，将一组命令存放在磁盘映像中，系统可以解释执行

实验环境:
物理机操作系统: Arch Linux 4.4.5-1
主要使用虚拟机: qemu-system-i386
虚拟机软件: VMware Workstation 12 Pro
虚拟机配置: CPU: i7-4702MQ @ 2.20GHz, 使用单核单线程
			内存:4 MB
			硬盘:32 MB
注意: 由于qemu, bochs和VMware Workstation模拟的CPU速率不同,
会导致动画的播放观赏性不好. 为了兼容这三个平台,
将系统的时钟调到了每秒20次中断, 并且调整了各个用户程序的刷新频率. 
在编写系统的过程中, 让动画效果适应qemu和Bochs
在后期编写中, 将动画效果适应VMware Workstation, 因此在qemu和bochs上会反映很慢.
将会在之后的实验中, 用系统时钟解决.

实验工具
编辑器: Vim 7.4
汇编工具: NASM 2.11.08
C++编译器: g++ 5.3.0
链接工具: GNU ld 2.26.0.20160302
构建工具: GNU Make 4.1
调试工具: Bochs x86 Emulator 2.6.8
虚拟机: qemu-system-i386

实验特色:
这次设计的操作系统有很大的亮点
首先是该系统同时支持分时处理多个进程, 和批处理进程.
在内存允许下, 该分时系统支持创建无限多个进程
可以根据进程的ID值杀死进程, 也可以一次杀死全部进程
有良好的控制台界面, 方便的命令行, 用户界面切换方式
支持检查复杂的指令, 能够判断指令是否正确
使用了g++和nasm交叉编译, 运行的环境为16进制实模式
支持函数互调, 

实验方案:
C++与nasm交叉编译:
nasm可以将汇编代码编译为.o 目标文件
g++也可以将C++代码编译为.o 目标文件
(这里不使用C语言, 我的理解是, 从编译原理的角度讲,
当C++代码不使用C++与C想比较的特性时, 编译出的指令效率和C语言是一样的,
并且C++的编写比C更方便)

生成.o 目标文件后, 将它们链接, 生成.bin文件,
这个文件为不包含头区域的二进制纯指令.
使用ld链接时, 可以选择参数-Ttext offset, 在声明生成的代码将会放在什么区域,
类似汇编中的org声明.

互调函数/例程:
要使nasm的例程能被C++调用, 需要以下步骤:
以本系统的杀死进程函数为例
1. 在nasm汇编代码的该例程前声明global 函数名, 即global KillProg
2. 在c++代码中声明extern "C" void KillProg(osi);
(这里的osi即类型uint16_t, 之所以起别名是为了将来把程序扩展到32位)
C++会将从最后一个参数到第一个参数依次压栈, 而nasm中的ax为函数的返回值.

nasm调用C++函数
在nasm汇编代码前声明extern 函数名
然后使用call 函数名 即可

注意事项:
g++和nasm中的函数互调不用考虑下划线_.
由于g++编译出的文件不是真正的16位指令, 难免会产生不兼容的形象.
有以下解决方法: 
1. nasm汇编编写为C++调用的例程时, 返回时用o32 ret
2. C++的函数带参数时, 在前面声明__attribute__((regparm(x)))
其中x为参数个数(不包含带默认参数的参数), 这段话告诉编译器,
使用x个寄存器存储参数, 这样可以避免压栈大小不一致带来的问题.


共享变量:
nasm汇编中的变量, 声明global 变量名后, 在C++中写extern "C" 变量类型 变量名
即可共享.

引导:
本系统的loader为主引导程序, 该程序运行后, 将内核从软盘写入内存的0:0x7e00处,
并跳转到该位置执行内核.
内核是由nasm代码和c++代码混合而成, 首先进行基本的寄存器设值, 中断的声明,
然后跳转到C++编写的Shell中.

分时系统:
分时系统是本次实验的最大亮点, 它的分时功能由内核kernel的汇编胡分实现,
拥有一个可扩展的PCB表, 在内存的允许下可以创建任意多的进程.
(由于技术原因, 暂时限定最大进程数)
同一个程序可以创建多个进程.
核心描述:
这里使用了08H时钟中断, 每次时钟中断发生时, 
1. 屏蔽中断,
2. 计算出当前进程的PCB表位置, 将所有寄存器的值保存到该PCB中(PCB为内存的一段区域)
3. 进入调度系统, 一般方式为切换到下一进程
4. 恢复新的进程的原寄存器值
5. 取消屏蔽中断
6. 中断返回

这里用到了很巧妙的方法, 当中断发生时, flags, cs, ip依次压栈, 在第4步时,
将栈中的这三个值更换为新进程的对应值, 然后中断返回

创建进程:
内部有一个ID计数器: ProgressIDAssigner
通过其计数, 可以确定不同的程序的内存分配段地址
将程序写入内存后, 修改PCB表, 进程数加一
之后实验会通过标记来判断空闲内存

删除进程:
用PCB表中最后一个进程的数据覆盖要删除的进程
进程数减一

Shell:
使用了屏幕输出, 光标控制, 键盘输入等中断
滚屏效果:
主要使用了10h号中断的0Eh功能, 可以实现滚屏效果, 而这个中断打印的字是无色的,
因此使用10h号中断获取光标的位置, 计算在B800内存区域的对应位置, 用彩色字符替换.
C++实现了一个叫buf的缓冲区, 用来记录指令的输入, 但输入回车时,
调用Execute函数进行指令分析, 然后执行.

批处理:
有一个batchList列表, 它可以存储要执行的程序的序号, 依次执行

返回Shell:
由于是分时系统, 实现的原理为一个Shell进程和多个用户进程, 用户进程受Shell管理.
有两种方式返回Shell
1. 当Shell判断到Esc键按下时, 从用户进程界面切换到Shell.
2. 当Shell判断Ctrl+Z按下时, 将所有用户进程杀死, 返回Shell. 

小结:
这次实验, 我耗的精力巨大, 根据我Github上私有库的提交记录,
这次实验的提交次数高达40次, 连续提交天数9天. 代码增加了3000多行.
我的目标是实现一个分时系统, 在这段时间中, 虽然我也学习了保护模式的编写,
但考虑到实现难度和可用时间, 我选择了首先实现分时系统.
我一早就想实现分时系统了, 无奈参考资料很少,
大部分分时系统的实现都是基于高级语言的, 我也想过用高级语言实现分时系统,
但觉得透明性太多, 不知道内部寄存器如何被修改.
实现分时系统, 我首先遇到的问题是, 如何使用时钟中断?
我查了大量资料, 可是很多资料是从硬件层面上介绍硬件接口,
连一个简单的范例都很难找.
我测试时钟中断是否有效, 是使用极其简单的方式, 写一个简单的程序看字符是否会被修改.
学习使用时钟中断的过程中, 我也在学习C语言和nasm的交叉编译, 其中掉进了很多坑,
从中我的最大收获是了解了qemu, bochs是如何使用的, Makefile是如何编写的.
学习交叉编译, 花了差不多一周的时间, 遇到了比如找不到_start入口的链接问题,
压栈的不兼容性, 指令占用过多扇区的处理.
分时系统的实现也是从很简单的程序开始, 首先测试只有一个进程时,
该进程是否能运行正常. 最好笑的是, 我发现了nasm编译的一个bug,
它有时会少编译一条指令, 我的解决方式是在缺失指令前加nop 
这次光调试, 用bochs的次数就有几百次, 期间还多次使用反汇编查看指令.
我敢说这次实验我付出了很多, 同时也收获很多.
